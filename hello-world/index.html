<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="同步器框架 AQS"><meta name="keywords" content="Java,Concurrent,AQS"><meta name="author" content="hkllyx"><meta name="copyright" content="hkllyx"><title>同步器框架 AQS | hkllyX's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?40ff2d3adb1213ddea5226876512b42b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-145057691-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"QHBIQM1E93","apiKey":"e18406ec91b6ef867904acc10c342ff5","indexName":"hkllyx_blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#aqs"><span class="toc-number">1.</span> <span class="toc-text"> AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用"><span class="toc-number">1.1.</span> <span class="toc-text"> 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#核心思想"><span class="toc-number">1.2.</span> <span class="toc-text"> 核心思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计与实现"><span class="toc-number">1.3.</span> <span class="toc-text"> 设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步状态"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 同步状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的阻塞与唤醒"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 线程的阻塞与唤醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排队机制"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 排队机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aqs-的嵌套类-node"><span class="toc-number">1.4.</span> <span class="toc-text"> AQS 的嵌套类 Node</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#等待状态waitstatus"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 等待状态（waitStatus）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字段-属性"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 字段 / 属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aqs-的嵌套类-conditionobject"><span class="toc-number">1.5.</span> <span class="toc-text"> AQS 的嵌套类 ConditionObject</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基于-aqs-的同步器"><span class="toc-number">2.</span> <span class="toc-text"> 基于 AQS 的同步器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#semaphore"><span class="toc-number">2.1.</span> <span class="toc-text"> Semaphore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#countdownlatch"><span class="toc-number">2.2.</span> <span class="toc-text"> CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三种典型用法"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 三种典型用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cylicbarrier"><span class="toc-number">2.3.</span> <span class="toc-text"> CylicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reentrantlock"><span class="toc-number">2.4.</span> <span class="toc-text"> ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#公平锁"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-与-synchronized-的区别"><span class="toc-number">2.4.2.</span> <span class="toc-text"> Lock 与 synchronized 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reentrantreadwritelock"><span class="toc-number">2.5.</span> <span class="toc-text"> ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#支持的属性"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 支持的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁与互斥锁的区别"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 读写锁与互斥锁的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用法"><span class="toc-number">2.5.3.</span> <span class="toc-text"> 用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#阅读"><span class="toc-number">3.</span> <span class="toc-text"> 阅读</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/33376125?s=400&amp;u=3d6627c61f66b14c53351a7e5663fecd141e2566&amp;v=4"></div><div class="author-info__name text-center">hkllyx</div><div class="author-info__description text-center">沁</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">1</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/hkllyx/PicBed/master/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">hkllyX's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">总览</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">同步器框架 AQS</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><span class="post-meta__separator">|</span><i class="fa fa-comments post-meta__icon" aria-hidden="true"></i><a href="/hello-world/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="hello-world/"></span></a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">8.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 27 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h1>
<p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code>，这个类位于 java.util.concurrent.locks 包下。</p>
<p>AQS 提供了一个用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器的框架，这些同步器依赖一个单个原子的 int 值表示同步状态。AQS 的子类必须定义修改同步状态的 protected 方法，并且定义这个获取和是否这个类的含义。给定这些方法后，该类的其他方法可以执行全部的排队和阻塞机制。子类也可以维护其他状态字段，可以使用 <code>getState()</code>、<code>setState(int)</code>、<code>compareAndSetState(int, int)</code> 方法操纵表示状态的 int 值，但是必须原子性地更新状态值以保证同步。</p>
<p>应该将 AQS 的子类定义为同步器类的非 public 内部帮助类（内部嵌套类），同步器类可用它们来实现其封闭类的同步属性。AQS 没有实现任何同步接口。而是定义了诸如 <code>acquireInterruptibly(int)</code> 之类的一些方法，在适当的时候可以通过具体的锁和相关同步器来调用它们，以实现其公共方法。</p>
<p>AQS 默认支持独占模式和共享模式：</p>
<ul>
<li>独占模式（Exclusive Mode）：同一时刻最多只有一个线程获取同步状态，处于该模式下，其他线程试图获取该锁将无法获取成功。</li>
<li>共享模式（Shared Mode）：同一时刻会有多个线程获取共享同步状态，处于该模式下，其他线程试图获取该锁可能（但不是一定）会获取成功。</li>
</ul>
<p>AQS 并不“了解”模式的不同，除了机械地意识到当在共享模式下成功获取某一锁时，如果下一个等待线程存在，那么该线程也必须确定自己是否可以成功获取该锁。处于不同模式下的等待线程可以共享相同的 FIFO 队列。通常，实现子类只支持其中一种模式，但两种模式都可以在（例如 <code>ReadWriteLock</code>）中发挥作用。只支持一种模式的子类不必重写不支持的另一种模式的方法。</p>
<p>AQS 提供了一个实现了 <code>java.util.concurrent.locks.Condition</code> 接口的嵌套类 —— <code>ConditionObject</code>。这个类为支持独占模式的 AQS 子类提供管程式的 <code>await</code>/<code>signal</code>/<code>signalAll</code> 操作。支持独占模式的 AQS 子类的子类提供了</p>
<ul>
<li><code>isHeldExclusively()</code> 方法用于判断一个同步器对象是否是被当前线程独占，</li>
<li><code>release(int)</code> 方法使用电当前 getState() 返回值可以完全释放同步器对象。</li>
<li><code>acquire(int)</code> 方法可以在给定保存的状态值下，将此对象最终恢复为它以前获取的状态。</li>
</ul>
<p>如果 AQS 子类中不支持独占模式，则不应该使用 ConditionObject 类。当然，ConditionObject 的行为当然取决于其同步器实现的语义。</p>
<p>AQS 为内部的队列提供了检查、检测和监视方法，还为 condition 对象提供了类似方法。可以根据需要将这些方法其导出到基于 AQS 实现的同步机制。</p>
<p>AQS 的序列化只存储维护状态的基础原子整数，因此已序列化的对象拥有空的线程队列。需要可序列化的典型子类将定义一个 readObject 方法，该方法在反序列化时将此对象恢复到某个已知初始状态。</p>
<p>使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如 ReentrantLock、CounDownLatch、Semaphore，其他的诸如 ReentrantReadWriteLock、SynchronousQueue、FutureTask 等等皆是基于 AQS 的。此外，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2>
<p>为了将此类用作同步器的基础，需要适当地重新定义以下方法，这些方法通过使用 <code>getState()</code>、<code>setState(int)</code>、<code>compareAndSetState(int, int)</code> 方法来检查、修改同步状态来实现：</p>
<ul>
<li><code>tryAcquire(int)</code></li>
<li><code>tryRelease(int)</code></li>
<li><code>tryAcquireShared(int)</code></li>
<li><code>tryReleaseShared(int)</code></li>
<li><code>isHeldExclusively()</code></li>
</ul>
<p>默认情况下，每个方法都抛出 UnsupportedOperationException。这些方法的实现在内部必须是线程安全的，通常应该很短并且不被阻塞。定义这些方法是使用此 AQS 的唯一支持的方式。其他所有方法都被声明为 final，因为它们无法是各不相同的。</p>
<p>此外也可以使用 AQS 父接口 <code>AbstractOwnableSynchonizer</code> 中的方法，该接口的方法用于 get/set 拥有独占锁的线程。鼓励使用这两个方法，用于监视和检查是哪个线程用于锁。</p>
<p>即使 AQS 基于一个 FIFO 队列，也无法强行实施 FIFO 的获取策略，<strong>独占同步的核心</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Acquire:</span><br><span class="line">    while (!tryAcquire(arg)) &#123;</span><br><span class="line">        enqueue thread if it is not already queued;</span><br><span class="line">        possibly block current thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Release:</span><br><span class="line">    if (tryRelease(arg))</span><br><span class="line">        unblock the first queued thread;</span><br></pre></td></tr></table></figure>
<p>共享模式与此类似，但可能涉及级联信号。</p>
<p>因为检查线程的获取状况是在入队之前执行的，所以新获取锁的线程可能闯入（barge）其他被阻塞的和已入队的线程之前。不过如果需要，可以通过定义 <code>tryAcquire</code>、<code>tryAcquireShared</code> 来禁用闯入，这两个方法内部调用一个或多个检查方法。因此可以提供一个公平的 FIFO 获取顺序。特别地，大部分公平同步器可以定义 <code>tryAquire</code> 在 <code>hasQueuedPredecessors()</code>（一个专门设计用于公平同步器的方法） 返回 true 的时候返回 false。其他变化也是可能的。</p>
<p>特别是 <code>getFirstQueuedThread()</code> 没有返回当前线程的时候，严格的 FIFO 锁定可以定义 <code>tryAcquire</code> 立即返回 false。只有 <code>hasQueuedThreads()</code> 返回 true 并且 <code>getFirstQueuedThread</code> 不是当前线程时，更好的非严格公平的版本才可能会立即返回 false；如果 getFirstQueuedThread 不为 null 并且不是当前线程，则产生的结果相同。出现进一步的变体也是有可能的。</p>
<p>对于默认为闯入（也称为 greedy、renouncement 和 convoy-avoidance）策略的同步器，吞吐量和可伸缩性通常是最高的。尽管无法保证这是公平的或是无偏向的，但允许更早加入队列的线程先于更迟加入队列的线程再次争用资源，并且相对于传入的线程，每个参与再争用的线程都有平等的成功机会。此外，尽管从一般意义上说，获取并非“自旋”，它们可以在阻塞之前对用其他计算所使用的 <code>tryAcquire</code> 执行多次调用。在只保持独占同步时，这为自旋提供了最大的好处，但不是这种情况时，也不会带来最大的负担。如果需要这样做，那么可以使用“快速路径”检查来先行调用 <code>acquire</code> 方法，以这种方式扩充这一点，如果可能不需要争用同步器，则只能通过预先检查 <code>hasContended()</code>、<code>hasQueuedThreads()</code> 来确认这一点。</p>
<p>通过特殊化其同步器的使用范围，AQS 为部分同步化提供了一个有效且可伸缩的基础，同步器可以依赖于 int 型的 state、acquire 和 release 参数，以及一个内部的 FIFO 等待队列。这些还不够的时候，可以使用 atomic 类、自己的定制 Queue 类和 LockSupport 阻塞支持，从更低级别构建同步器。</p>
<h2 id="核心思想"><a class="markdownIt-Anchor" href="#核心思想"></a> 核心思想</h2>
<p>AQS 核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<h2 id="设计与实现"><a class="markdownIt-Anchor" href="#设计与实现"></a> 设计与实现</h2>
<p>在 AQS 的使用中已经说明，AQS 的核心便是 Acquire 和 Release 操作。为了实现上述者两个操作，需要完成以下三个功能：</p>
<ul>
<li>同步状态的原子性管理；</li>
<li>线程的阻塞与唤醒；</li>
<li>排队机制；</li>
</ul>
<h3 id="同步状态"><a class="markdownIt-Anchor" href="#同步状态"></a> 同步状态</h3>
<p>AQS 类通过使用单个 int 类型来保存同步状态，并提供了 <code>getState()</code>、 <code>setState(int)</code>、<code>compareAndSetState(int, int)</code> 三个方法来读取和更新状态，并且此同步状态通过关键字 volatile 修饰，保证了多线程环境下的可见性，更新同步状态是由 CAS 实现的，当多个线程同时对某个资源进行 CAS 操作的时候，只能有一个线程操作成功，但并不会阻塞其他线程，其他线程会收到操作失败的信号，CAS 是一个轻量级的乐观锁。CAS 的底层通过 Unsafe 类实现的，利用处理器提供的 CMPXCHG 指令实现其原子性，使得仅当同步器状态为一个期望值的时候，才会被原子的更新成目标值，相比 synchronized 不会导致过多的上下文切换切换和挂起线程。在 java.util.concurrent 包中，大量地使用 CAS 来实现原子性。</p>
<h3 id="线程的阻塞与唤醒"><a class="markdownIt-Anchor" href="#线程的阻塞与唤醒"></a> 线程的阻塞与唤醒</h3>
<p><code>LockSupport</code> 类是一个非常方便的线程阻塞工具类，它可以在线程任意位置让线程阻塞。和Thread.suspend() 相比，它弥补了由于 resume() 在前发生，导致线程无法继续执行的情况。和 Object.wait() 相比，它<strong>不需要先获得某个对象的锁，也不会抛出 InterruptedException 异常</strong>。LockSupport.park() 方法阻塞当前线程，这是因为 LockSupport 类使用类似信号量的机制，它为每一个线程准备了一个许可，如果许可可用，那么 park() 会立即返回，并且消费这个许可（设置许可不可用），就会阻塞，而 unpark() 则使得一个许可变为可用（但是和信号量不同的是，许可不可累加可用，你不可能拥有超过一个许可，它永远只有一个）。</p>
<h3 id="排队机制"><a class="markdownIt-Anchor" href="#排队机制"></a> 排队机制</h3>
<p>同步队列 AQS 整个框架的关键都是如何管理被阻塞线程的队列，在 AQS 中，运用到了 CLH 锁的思想，CLH 锁被用于自旋锁，可以确保没有饥饿感，提供先到先得的公平服务，CLH锁是基于列表的可伸缩，高性能，公平和自旋锁，应用程序线程仅在局部变量上旋转，它不断轮询前驱状态，如果发现预释放锁定结束旋转。</p>
<p>AQS 同步队列是一个 FIFO 队列，在此同步队列中，一个节点表示一个线程，它保存着线程的引用、状态、前驱节点、后继节点。同步队列通过两个节点 tail 和 head 来存取，初始化时，tail、head 初始化为一个空节点，线程要加入到同步队列中，通过 CAS 原子地拼接为新的 tail 节点，线程要退出队列，只需设置 head 节点指向当前线程节点。<br>
<img src="img/022.png" alt></p>
<p>同步队列的优点在于<strong>其出队和入队的操作都是无锁的、快速的</strong>。为了将 CLH 锁队列用于阻塞同步器，该同步队列需要做些额外的修改以提供一种高效的方式定位某个节点的后继节点，在自旋锁中，一个节点只需改变其状态，下一次自旋中其后继节点就能注意到这个改变。但是在阻塞式同步器中，一个节点需要显示地唤醒其后继节点。同步队列包含一个 next 链接到它的后继节点。第二个对 CLH 锁队列主要的修改是将每个节点都有的状态字段用于控制阻塞而非自旋。</p>
<p>此外 ConditionObject 也拥有一对表示第一个等待结点和最后一个结点，它们也维护了一个等待队列。</p>
<h2 id="aqs-的嵌套类-node"><a class="markdownIt-Anchor" href="#aqs-的嵌套类-node"></a> AQS 的嵌套类 Node</h2>
<p>表示等待队列中的结点。</p>
<p>等待队列是一个 “CLH” 锁队列的变体。CLH 锁队列通常用于自旋锁。不使用它们来阻塞同步器，而是使用一些相同的基本策略保存它们的结点的前驱的</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。</p>
</blockquote>
<h3 id="等待状态waitstatus"><a class="markdownIt-Anchor" href="#等待状态waitstatus"></a> 等待状态（waitStatus）</h3>
<p>每一个 Node 都有一个等待状态。等待状态共有 5 类：</p>
<ul>
<li><strong>CANCELLED</strong>：由于超时或中断，此节点被取消。节点永远不会离开这个状态。特别的是，一个节点被取消的线程再也不会阻塞。</li>
<li><strong>SIGNAL</strong>：此节点的后继节点已经或很快将通过 park 被阻塞，因此当前节点在释放或取消时必须 unpark 其后继节点。为了避免竞争，acquire 方法必须首先表明它们需要一个信号然后重试原子获取，如果失败，则阻塞。</li>
<li><strong>CONDITION</strong>：此节点当前位于 condition 队列中，表示正在等待。此节点不会被用作 sync 队列节点，直至被转移（转移时状态将被设置为 0，这个 0 值特殊含义，只是为了简化机制）。</li>
<li><strong>PROPAGATE</strong>：一个节点的 releaseShare 操作应该被传播到其他的结点。这个状态在 doReleaseShared 中且只能能对 head 结点设置，目的是保证即使其他操作接入传播也能继续进行。</li>
<li><strong>0</strong>：不是上面的任一个。</li>
</ul>
<h3 id="字段-属性"><a class="markdownIt-Anchor" href="#字段-属性"></a> 字段 / 属性</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    /** 表示节点正在共享模式中等待的标记 */</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    /** 表示节点正在独占模式中等待的标记 */</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    /** 上述的五个等待状态，省略 */</span><br><span class="line"></span><br><span class="line">    /** 等待状态，一般 sync 结点为 0，condition 结点为 CONDITION。</span><br><span class="line">     * 通过 CAS 更新，也可能只是 volatile 写。</span><br><span class="line">     */</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链接到当前结点用于检测等待状态的前驱结点，在入队时赋值，只有在出队后设为 null。</span><br><span class="line">     * 当然，当前驱节点被取消时，我们在寻找一个未被取消的前驱节点时发生短路，这个前驱节点总是存在的，因为 head 不可能被取消：</span><br><span class="line">     * 一个节点只有在成功获取后才能成为 head，而被取消的线程永远不可能成功获取，并且一个结点只能取消它自己。</span><br><span class="line">     */</span><br><span class="line">    volatile Node prev;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 连接到当前节点 release 后需要 unpark 的后继结点。在入队时分配，在前驱结点需要时调整，在出队时设为 null。</span><br><span class="line">     * 入队操作只有在有在附件之后才会对前驱结点的 next 赋值，所以一个结点的 next 为 null 时不能表示他是队列的最后一个结点，需要从 tail 向前查看才能确定。</span><br><span class="line">     * 一个被取消的结点 next 指向它自己。</span><br><span class="line">     */</span><br><span class="line">    volatile Node next;</span><br><span class="line"></span><br><span class="line">    /** 结点保存的线程。初始化时赋值，使用完设为 null */</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    /** 链接到 condition 列队中的下一结点，或者为特殊的 SHARED。</span><br><span class="line">     * 因为 condition 列队只会在独占模式下产生，所以只需要一个指向下一个等待结点的链接，</span><br><span class="line">     * 且需要在字段中指明其特殊状态（CONDITION）。</span><br><span class="line">     * 这些结点可以被转移到 sync 列队重新获取锁。</span><br><span class="line">     */</span><br><span class="line">    Node nextWaiter;</span><br></pre></td></tr></table></figure>
<h2 id="aqs-的嵌套类-conditionobject"><a class="markdownIt-Anchor" href="#aqs-的嵌套类-conditionobject"></a> AQS 的嵌套类 ConditionObject</h2>
<p>事 Condition 接口的实现类，为基于 AQS 的 Lock 接口的实现类提供服务。</p>
<p>此类的方法文档描述了一些机制，但没有从 Lock 和 Condition 用户的角度描述行为规范。此类的发行版本通常必须和描述 condition 语义的文档一起提供，这些语义依赖于相关 AbstractQueuedSynchronizer 的那些语义。</p>
<p>此类是可序列化的，但所有字段都是瞬态的，所以已序列化的条件没有等待者。</p>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<ul>
<li>await()：实现可中断的条件等待。</li>
<li>await(long, TimeUnit)：实现定时的条件等待</li>
<li>awaitUninterruptibly()：实现不可中断的条件等待</li>
<li>awaitUtil(Date)：实现绝对定时的条件等待</li>
<li>signal()：将等待时间最长的线程（如果存在）从此条件的等待队列移动到拥有锁的等待队列。</li>
<li>signalAll()：将此条件的等待队列中的所有线程移动到拥有锁的等待队列。</li>
</ul>
<h1 id="基于-aqs-的同步器"><a class="markdownIt-Anchor" href="#基于-aqs-的同步器"></a> 基于 AQS 的同步器</h1>
<h2 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h2>
<p>一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 <code>acquire()</code>，然后再获取该许可。每个 <code>release()</code> 增加一个许可，从而可能释放一个被阻塞的获取者。但是，Semaphore 没有使用真正的许可对象，只是对可用许可的计数，并采取相应的行动。Semaphore 通常用于限制可以访问某些资源（物理或逻辑的）的线程数目。</p>
<p>获得一项前，每个线程必须从信号量获取许可，从而保证可以使用该项。该线程结束后，将项返回到池中并将许可返回到该信号量，从而允许其他线程获取该项。注意，调用 <code>acquire()</code> 时无法保持同步锁，因为这会阻止将项返回到池中。信号量封装所需的同步，以限制对池的访问，这同维持该池本身一致性所需的同步是分开的。</p>
<p>将信号量初始化为 1，使得它在使用时最多只有一个可用的许可，从而可用作一个互斥锁。这通常也称为 Binary Semaphore，因为它只能有两种状态：一个可用的许可，或零个可用的许可。按此方式使用时，其具有某种属性（与很多 Lock 实现不同），即可以由线程释放“锁”，而不是由所有者（因为信号量没有所有权的概念）。在某些专门的上下文（如死锁恢复）中这会很有用。</p>
<p>此类的构造方法可选地接受一个公平参数。当设置为 false 时，此类不对线程获取许可的顺序做任何保证。特别地，闯入是允许的，也就是说可以在已经等待的线程前为调用 <code>acquire()</code> 的线程分配一个许可，从逻辑上说，就是新线程将自己置于等待线程队列的头部。当公平设置为 true 时，信号量保证对于任何调用获取方法的线程而言，都按照处理它们调用这些方法的顺序（即先进先出；FIFO）来选择线程、获得许可。注意，FIFO 排序必然应用到这些方法内的指定内部执行点。所以，可能某个线程先于另一个线程调用了 <code>acquire()</code>，但是却在该线程之后到达排序点，并且从方法返回时也类似。还要注意，非同步的 <code>tryAcquire</code> 方法不使用公平设置，而是使用任意可用的许可。</p>
<p>此类还提供便捷的方法来同时获取和释放多个许可。不管需要注意，在未将公平设置为 true 时使用这些方法会增加不确定延期的风险。</p>
<p>通常，应该将用于控制资源访问的信号量初始化为公平的，以确保所有线程都可访问资源。为其他的种类的同步控制使用信号量时，非公平排序的吞吐量优势通常要比公平考虑更为重要。</p>
<p><strong>内存一致性效果</strong>：线程中调用“释放”方法（比如 release()）之前的操作 happen-before 另一线程中紧跟在成功的“获取”方法（比如 acquire()）之后的操作。</p>
<h2 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> CountDownLatch</h2>
<p>一个同步辅助类，在完成<strong>一组</strong>正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p>
<p>用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次 —— 计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。</p>
<p>CountDownLatch 是一个通用同步工具，它有很多用途。将计数 1 初始化的 CountDownLatch 用作一个简单的开/关锁存器，或入口：在通过调用 countDown() 的线程打开入口前，所有调用 await 的线程都一直在入口处等待。用 N 初始化的 CountDownLatch 可以使一个线程在 N 个线程完成某项操作之前一直等待，或者使其在某项操作完成 N 次之前一直等待。</p>
<p>CountDownLatch 的一个有用特性是，它不要求调用 countDown 方法的线程等到计数到达零时才继续，而在所有线程都能通过之前，它只是阻止任何线程继续通过一个 await。</p>
<h3 id="三种典型用法"><a class="markdownIt-Anchor" href="#三种典型用法"></a> 三种典型用法</h3>
<p>某一线程在开始运行前等待 N 个线程执行完毕。将 CountDownLatch 的计数器初始化为 N，每当一个任务线程执行完毕，就调用 <code>countDown()</code> 方法将计数器减 1，当计数器的值变为 0 时，在 CountDownLatch 上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p>
<p>实现多个线程开始执行任务的最大并行性。<strong>注意是并行性，不是并发</strong>，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1，多个线程在开始执行任务前首先 调用 <code>await()</code> 等待，当主线程调用 <code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</p>
<p>死锁检测：一个非常方便的使用场景是，你可以使用 N 个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。</p>
<h2 id="cylicbarrier"><a class="markdownIt-Anchor" href="#cylicbarrier"></a> CylicBarrier</h2>
<p>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环的 barrier。</p>
<p>CyclicBarrier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作很有用。</p>
<p>如果屏障操作在执行时不依赖于正挂起的线程，则线程组中的任何线程在获得释放时都能执行该操作。为方便此操作，每次调用 await() 都将返回能到达屏障处的线程的索引。然后，您可以选择哪个线程应该执行屏障操作，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (barrier.await() == 0) &#123;</span><br><span class="line">    // log the completion of this iteration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于失败的同步尝试，CyclicBarrier 使用了一种要么全部要么全不 (all-or-none) 的破坏模式：如果因为中断、失败或者超时等原因，导致线程过早地离开了屏障点，那么在该屏障点等待的其他所有线程也将通过 BrokenBarrierException（如果它们几乎同时被中断，则用 InterruptedException）以反常的方式离开。</p>
<p>内存一致性效果：线程中调用 await() 之前的操作 happen-before 那些是屏障操作的一部份的操作，后者依次 happen-before 紧跟在从另一个线程中对应 await() 成功返回的操作。</p>
<h2 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> ReentrantLock</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, java.io.Serializable</span><br></pre></td></tr></table></figure>
<p>一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。ReentrantLock 将由最近成功获得锁，并且还没有释放该锁的线程所拥有。当锁没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁并返回。如果当前线程已经拥有该锁，此方法将立即返回。可以使用 <code>isHeldByCurrentThread()</code> 和 <code>getHoldCount()</code> 方法来检查此情况是否发生。</p>
<p>总是建议 <code>lock</code> 与 try-finally 连用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class X &#123;</span><br><span class="line">   private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">   // ...</span><br><span class="line"></span><br><span class="line">   public void m() &#123;</span><br><span class="line">     lock.lock();  // 阻塞，知道获取锁</span><br><span class="line">     try &#123;</span><br><span class="line">       // ...</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       lock.unlock();// 无论方法执行中是否出现异常，在 finally 中释放锁</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了实现 Lock 接口，此类还定义了 <code>isLocked</code> 和 <code>getLockQueueLength</code> 方法，以及一些相关的 protected 访问方法，这些方法对检测和监视可能很有用。</p>
<p>该类的序列化与内置锁的行为方式相同：一个反序列化的锁处于解除锁定状态，不管它被序列化时的状态是怎样的。</p>
<p>此锁最多支持同一个线程发起的 2147483648 个递归锁。试图超过此限制会导致由锁方法抛出的 Error。</p>
<h3 id="公平锁"><a class="markdownIt-Anchor" href="#公平锁"></a> 公平锁</h3>
<p>此类的构造方法接受一个可选的公平参数。当设置为 true 时，在多个线程的争用下，这些锁倾向于将访问权授予等待时间最长的线程。否则此锁将无法保证任何特定访问顺序。与采用默认设置（使用不公平锁）相比，使用公平锁的程序在许多线程访问时表现为很低的总体吞吐量（即速度很慢，常常极其慢），但是在获得锁和保证锁分配的均衡性时差异较小。不过要注意的是，<strong>公平锁不能保证线程调度的公平性</strong>。因此，使用公平锁的众多线程中的一员可能获得多倍的成功机会，这种情况发生在其他活动线程没有被处理并且目前并未持有锁时。还要注意的是，<strong>未指定超时时间的 <code>tryLock</code> 方法并没有使用公平设置</strong>。因为即使其他线程正在等待，只要该锁是可用的，此方法就可以获得成功。</p>
<h3 id="lock-与-synchronized-的区别"><a class="markdownIt-Anchor" href="#lock-与-synchronized-的区别"></a> Lock 与 synchronized 的区别</h3>
<p>synchronized 方法或语句的使用提供了对与每个对象相关的隐式监视器锁的访问，但却强制所有锁获取和释放均要出现在一个块结构中：当获取了多个锁时，它们必须以相反的顺序释放，且必须在与所有锁被获取时相同的词法范围内释放所有锁。</p>
<p>虽然 synchronized 方法和语句的范围机制使得使用监视器锁编程方便了很多，而且还帮助避免了很多涉及到锁的常见编程错误，但有时也需要以更为灵活的方式使用锁。例如，某些遍历并发访问的数据结果的算法要求使用 “hand-over-hand” 或 “chain locking”：获取节点 A 的锁，然后再获取节点 B 的锁，然后释放 A 并获取 C，然后释放 B 并获取 D，依此类推。<strong>Lock 接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁</strong>，从而支持使用这种技术。</p>
<h2 id="reentrantreadwritelock"><a class="markdownIt-Anchor" href="#reentrantreadwritelock"></a> ReentrantReadWriteLock</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantReadWriteLock</span><br><span class="line">             implements ReadWriteLock, java.io.Serializable</span><br></pre></td></tr></table></figure>
<p>支持与 ReentrantLock 类似语义的 ReadWriteLock 实现。</p>
<p>此类行为的序列化方式与内置锁的相同：反序列化的锁处于解除锁状态，无论序列化该锁时其状态如何。</p>
<p>此锁最多支持 65535 个递归写入锁和 65535 个读取锁。试图超出这些限制将导致锁方法抛出 Error。</p>
<h3 id="支持的属性"><a class="markdownIt-Anchor" href="#支持的属性"></a> 支持的属性</h3>
<ul>
<li>
<p>获取顺序</p>
<ul>
<li>此类不会将读取者优先或写入者优先强加给锁访问的排序。</li>
<li>但是，它确实支持可选的公平策略。</li>
</ul>
</li>
<li>
<p>非公平模式（默认）</p>
<ul>
<li>当非公平地（默认）构造时，未指定进入读写锁的顺序，受到 reentrancy 约束的限制。- 连续竞争的非公平锁可能无限期地推迟一个或多个 reader 或 writer 线程，但吞吐量通常要高于公平锁。</li>
</ul>
</li>
<li>
<p>公平模式</p>
<ul>
<li>当公平地构造线程时，线程利用一个<strong>近似</strong>到达顺序的策略来争夺进入。当释放当前保持的锁时，可以为等待时间最长的单个 writer 线程分配写入锁，如果有一组等待时间大于所有正在等待的 writer 线程 的 reader 线程，将为该组分配写入锁。</li>
<li>如果保持写入锁，或者有一个等待的 writer 线程，则试图获得公平读取锁（非重入地）的线程将会阻塞。直到当前最旧的等待 writer 线程已获得并释放了写入锁之后，该线程才会获得读取锁。当然，如果等待 writer 放弃其等待，而保留一个或更多 reader 线程为队列中带有写入锁自由的时间最长的 waiter，则将为那些 reader 分配读取锁。</li>
<li>试图获得公平写入锁的（非重入地）的线程将会阻塞，除非读取锁和写入锁都自由（这意味着没有等待线程）。（注意，非阻塞的读写锁的 <code>tryLock()</code> 方法都不会遵守此公平设置，并将获得锁（如果可能），不考虑等待线程）。</li>
</ul>
</li>
<li>
<p>重入</p>
<ul>
<li>此锁允许 reader 和 writer 按照 ReentrantLock 的样式重新获取读取锁或写入锁。在写入线程保持的所有写入锁都已经释放后，才允许重入 reader 使用它们。</li>
<li>此外，<strong>writer 可以获取读取锁，但反过来则不成立</strong>。在其他应用程序中，当在调用或回调那些在读取锁状态下执行读取操作的方法期间保持写入锁时，重入很有用。如果 reader 试图获取写入锁，那么将永远不会获得成功。</li>
</ul>
</li>
<li>
<p>锁降级</p>
<ul>
<li>重入还允许从写入锁降级为读取锁，但是，从读取锁升级到写入锁是不可能的。</li>
<li>锁降级实现方式：<strong>先获取写入锁，然后获取读取锁，最后释放写入锁</strong>。</li>
</ul>
</li>
<li>
<p>锁获取的中断</p>
<ul>
<li>读取锁和写入锁都支持锁获取期间的中断。</li>
</ul>
</li>
<li>
<p>Condition 支持</p>
<ul>
<li>写入锁提供了一个 Condition 实现，对于写入锁来说，该实现的行为与 ReentrantLock.newCondition() 提供的 Condition 实现对 ReentrantLock 所做的行为相同。当然，此 Condition 只能用于写入锁。</li>
<li><strong>读取锁不支持 Condition</strong>，readLock().newCondition() 会抛出 UnsupportedOperationException。</li>
</ul>
</li>
<li>
<p>监测</p>
<ul>
<li>此类支持一些确定是保持锁还是争用锁的方法。</li>
<li>这些方法设计用于监视系统状态，而不是同步控制</li>
</ul>
</li>
</ul>
<h3 id="读写锁与互斥锁的区别"><a class="markdownIt-Anchor" href="#读写锁与互斥锁的区别"></a> 读写锁与互斥锁的区别</h3>
<p>与互斥锁相比，<strong>读-写锁允许对共享数据进行更高级别的并发访问</strong>。虽然一次只有一个线程（writer 线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程），读-写锁利用了这一点。从理论上讲，与互斥锁相比，使用读-写锁所允许的并发性增强将带来更大的性能提高。在实践中，<strong>只有在多处理器上并且只在访问模式适用于共享数据时，才能完全实现并发性增强</strong>。</p>
<p>与互斥锁相比，使用读-写锁能否提升性能则取决于读写操作期间读取数据相对于修改数据的频率，以及数据的争用 —— 即在同一时间试图对该数据执行读取或写入操作的线程数。例如，某个最初用数据填充并且之后不经常对其进行修改的 collection，因为经常对其进行搜索（比如搜索某种目录），所以这样的 collection 是使用读-写锁的理想候选者。但是，如果数据更新变得频繁，数据在大部分时间都被独占锁，这时，就算存在并发性增强，也是微不足道的。更进一步地说，如果读取操作所用时间太短，则读-写锁实现（它本身就比互斥锁复杂）的开销将成为主要的执行成本，在许多读-写锁实现仍然通过一小段代码将所有线程序列化时更是如此。最终，只有通过分析和测量，才能确定应用程序是否适合使用读-写锁。</p>
<h3 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h3>
<p>展示了如何利用重入来执行升级缓存后的锁降级（为简单起见，省略了异常处理）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class CachedData &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    volatile boolean cacheValid;</span><br><span class="line">    ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    void processCachedData() &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        if (!cacheValid) &#123;</span><br><span class="line">           // 获取写入锁之前必须是否读锁</span><br><span class="line">           rwl.readLock().unlock();</span><br><span class="line">           rwl.writeLock().lock();</span><br><span class="line">           // 再次确认状态，因为别的线程可能先于当前线程已经获取了写入锁并修改了状态</span><br><span class="line">           if (!cacheValid) &#123;</span><br><span class="line">             data = ...</span><br><span class="line">             cacheValid = true;</span><br><span class="line">           &#125;</span><br><span class="line">           // 降级锁</span><br><span class="line">           rwl.readLock().lock();</span><br><span class="line">           rwl.writeLock().unlock(); // 释放写入锁，但仍保持者写入锁</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        use(data);</span><br><span class="line">        rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用某些种类的 Collection 时，可以使用 ReentrantReadWriteLock 来提高并发性。通常，在预期 collection 很大，<strong>读取者线程访问它的次数多于写入者线程</strong>，并且 entail 操作的开销高于同步开销时，这很值得一试。例如，以下是一个使用 TreeMap 的类，预期它很大，并且能被同时访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class RWDictionary &#123;</span><br><span class="line">    private final Map&lt;String, Data&gt; m = new TreeMap&lt;String, Data&gt;();</span><br><span class="line">    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    private final Lock r = rwl.readLock();</span><br><span class="line">    private final Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    public Data get(String key) &#123;</span><br><span class="line">        // 读取数据使用读锁</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123; return m.get(key); &#125;</span><br><span class="line">        finally &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public String[] allKeys() &#123;</span><br><span class="line">        // 读取数据使用读锁</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123; return m.keySet().toArray(); &#125;</span><br><span class="line">        finally &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Data put(String key, Data value) &#123;</span><br><span class="line">        // 插入数据使用写锁</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123; return m.put(key, value); &#125;</span><br><span class="line">        finally &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        // 删除数据使用写锁</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123; m.clear(); &#125;</span><br><span class="line">        finally &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="阅读"><a class="markdownIt-Anchor" href="#阅读"></a> 阅读</h1>
<p><a href="http://ifeve.com/aqs/" target="_blank" rel="noopener">The j.u.c Synchronizer Framework中文翻译版</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">hkllyx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hkllyx.github.io/hello-world/">http://hkllyx.github.io/hello-world/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hkllyx.github.io">hkllyX's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Concurrent/">Concurrent</a><a class="post-meta__tags" href="/tags/AQS/">AQS</a></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://hkllyx.github.io/hello-world/';
  this.page.identifier = 'hello-world/';
  this.page.title = '同步器框架 AQS';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'hkllyx-github-io' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://hkllyx-github-io.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/hkllyx/PicBed/master/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By hkllyx</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">欢迎访问我的<a href="https://hkllyx.com">博客</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>